<h3>Semi-Automatic Variables</h3>
<p>JOE 3.6 uses "semi-automatic" variables for strings.  There is a global
"object-stack", accessed through these functions:</p>

<table width="100%" cellspacing=0>
<colgroup>
<col width="300">
<tbody>
<tr><td>void *obj_malloc(int size);</td><td>Allocate a block of memory.</td></tr>
<tr><td>void *obj_realloc(void *ptr, int size);</td><td>Change allocation size.</td></tr>
<tr><td>void obj_free(void *ptr);</td><td>Free a specified block and all newer blocks.</td></tr>
<tr><td>void obj_perm(void *ptr);</td><td>Mark a block as permanent, which in effect moves the block from the stack to the heap.</td></tr>
<tr><td>int obj_len(void *ptr);</td><td>Access hidden "length" part of block (string length).</td></tr>
<tr><td>int obj_size(void *ptr);</td><td>Access hidden "size" part of block (allocation size).</td></tr>
</tbody>
</table>

<p>These functions remember the order of allocation.  When an allocated
block is freed, it and all newer blocks are freed as well.  For example, in:</p>

<pre>
unsigned char *a = obj_malloc(10);
unsigned char *b = obj_malloc(10);
unsigned char *c = obj_malloc(10);
unsigned char *d = obj_malloc(10);

obj_free(b);
</pre>

<p>b, c, and d are all freed, but a remains allocated.  The top-level edit
loop is structured to call obj_free after every editor command:</p>

<pre>
unsigned char *gc = obj_malloc(1);
execmd(...); /* Execute edit commands */
obj_free(gc); /* Collect garbage */
</pre>

<p>Thus, you rarely have to call obj_free- the only time you might want to do
it is if you are calling obj_malloc in a loop.  This could cause a large
amount of memory to be allocated, so obj_free() should be called at the
end of each loop iteration.</p>

<p>obj_perm() marks an object as a heap object instead of a stack object. 
When a heap object is freed, only itself is freed- the stack is not
modified.  Also when the stack is freed, heap objects are not touched.</p>

<h3>Variable Strings</h3>

<p>JOE uses dynamic strings built on top of the global object stack
functions. These strings automatically resize themselves to fit their
contents.  They also know their own length, which allows you to have NULs in
the middle of a string.  They also always have a terminating NUL to make
them compatible with C-strings.  In fact they have (almost) the same type as
C-strings: unsigned char *.  The length is hidden in the obj_malloc data
structure.  These functions are provided:</p>

<table width="100%" cellspacing=0>
<colgroup>
<col width="400">
<tbody>
<tr><td>unsigned char *vsmk(int prealloc);</td><td>Allocate a zero length string, but with enough space to grow to the specified length.</td></tr>
<tr><td>int vslen(unsigned char *s);</td><td>Return string length or 0 if s is NULL.</td></tr>
<tr><td>unsigned char *vsensure(unsigned char *s, int len);</td><td>Make sure there is enough space for a string of the specified length.</td></tr>
<tr><td>usnigned char *vstrunc(unsigned char *s, int len);</td><td>Set length of string: the string is truncated or extended with spaces to the specified length.</td></tr>
<tr><td>unsigned char *vsncpy(unsigned char *s,int offset,unsigned char *block, int block_size);</td><td>Copy a memory block to a string.  The string is extended with spaces if offset &gt; string length.</td></tr>
<tr><td>unsigned char *vsdupz(unsigned char *s);</td><td>Duplicate a z-string to a variable string.</td></tr>
<tr><td>unsigned char *vsdup(unsigned char *s);</td><td>Duplicate a variable string.</td></tr>
<tr><td>unsigned char *vscpyz(unsigned char *s,unsigned char *z);</td><td>Copy a z-string to a variable string.</td></tr>
<tr><td>unsigned char *vscpy(unsigned char *s,unsigned char *block,int size);</td><td>Copy a memory block to a variable string.</td></tr>
<tr><td>unsigned char *vscatz(unsigned char *s,unsigned char *z);</td><td>Append a z-string to a variable string.</td></tr>
<tr><td>unsigned char *vscat(unsigned char *s,unsigned char *block,int size);</td><td>Append a memory block to a variable string.</td></tr>
<tr><td>unsigned char *vsadd(unsigned char *s,unsigned char c);</td><td>Append a single character to a string.</td></tr>
<tr><td>unsigned char *vsfmt(unsigned char *s,int offset,const char *format,...);</td><td>Sprintf() to a variable string.</td></tr>
<tr><td>unsigned char *vsgets(unsigned char **sp,FILE *f);</td><td>fgets() to a variable string (returns NULL on EOF, does not put '\n' in the string).</td></tr>
</tbody>
</table>

<p>Note that it is OK to pass NULL in place of 's' in any of the above
functions.  In this case, a new string is allocated.</p>

<p>Most of these function return the address of the variable string, in case
it was modified.  One exception is vsgets()- it takes an address of a
variable holding the string.  It returns the string address, but it also
writes it to the variable directly.</p>

<p>Many of the above functions take a memory block, which is specified by an
address and a length.  These macros can be used to help contruct these
arguments:</p>

<table width="100%" cellspacing=0>
<colgroup>
<col width="350">
<tbody>
<tr><td>#define sc(s) (s), (sizeof(s)-1)</td><td>For string constants.</td></tr>
<tr><td>#define sz(s) (s), zlen(s)</td><td>For C-strings (zlen is the same as strlen).</td></tr>
<tr><td>#define sv(s) (s), vslen(s)</td><td>For variable strings.</td></tr>
</tbody>
</table>


<p>So for example, vscatz is defined as:</p>

<pre>
unsigned char *vscatz(unsigned char *s, unsigned char *z);
{
	return vsncpy(sv(s), sz(z));
}
</pre>

<h3>Variable arrays of variable strings</h3>

<p>JOE also semi-automatic variable arrays of variable strings.  These
functions are provided:</p>

<table width="100%" cellspacing=0>
<colgroup>
<col width="400">
<tbody>
<tr><td>unsigned char *vamk(int prealloc);</td><td>Allocate a zero length array, but with enough space to grow to the specified length.</td></tr>
<tr><td>void varm(unsigned char **a);</td><td>Free an array.</td></tr>
<tr><td>int valen(unsigned char *a);</td><td>Return array length or 0 if a is NULL.</td></tr>
<tr><td>unsigned char *vaensure(unsigned char *s, int len);</td><td>Make sure there is enough space for an array of the specified length.</td></tr>
<tr><td>usnigned char *vatrunc(unsigned char *s, int len);</td><td>Set length of array: the array is truncated or extended with NULLs to the specified length.</td></tr>
<tr><td>unsigned char *vaadd(unsigned char **a,unsigned char *s);</td><td>Append a single string to an array.</td></tr>
<tr><td>unsigned char *vasort(unsigned char **a,int len);</td><td>Sort an array.</td></tr>
<tr><td>unsigned char *vawords(unsigned char **a,unsigned char *s,int len, unsigned char *sep, int seplen);</td><td>Convert a word list in s (words separated by characters given in sep/seplen) into an array of strings.</td></tr>
<tr><td>void vaperm(unsigned char **a);</td><td>Mark an array as preferment (heap instead of stack).</td></tr>
</tbody>
</table>

<p>When an array is marked as permanent, any strings in the array also
marked as permanent, and any string later added to the array are also marked
as permanent.</p>


<h3>Edit Buffers</h3>
<p>API:
</p>
<p>  Look at the comments in b.h for more information.
</p>
<p>  B *bfind(unsigned char *name);
		Load disk file into memory buffer 'B'.
</p>
<p>  bsave(P *p,unsigned char *name,int size);
		Write size bytes from buffer beginning at p to disk file
</p>
<p>  brm(b);	Free data structure
</p>
<p>Once you have a B you can access the characters in it via P pointers (which
are like C++ STL iterators).
</p>
<p>  B *b = bfind("foo");	Load file into memory
</p>
<p>  P *p = pdup(b-&gt;bof);	Get pointer to beginning of file (duplicate
			b-&gt;bof which is a P).
</p>
<p>  prm(p);		Free p when we're done with it.
</p>
<p>  int c=brch(p);	Get character at p.
  int c=pgetc(p);	Get character at p and advance it.
  int c=prgetc(p);	Retract p, then return character at it.
</p>
<p>    - These return -1 (NO_MORE_DATA) if you try to read end of file or
      before beginning of file.
</p>
<p>    - A pointer can point to any character of the file and right after the
      end of the file.
</p>
<p>    - For UTF-8 files, character can be between 0 and 0x7FFFFFFF
</p>
<p>  Publicly readable members of P:
	p-&gt;byte		The byte offset into the buffer
	p-&gt;line		The line number
	p-&gt;xcol		If P is the cursor, this is the column number
			where the cursor will be displayed on the screen
			(which does not have to match the column of the
			character at P).
</p>
<p>  Some predicates:
	pisbof(p);	True if pointer is at beginning of buffer
	piseof(p);	True if pointer is at end of buffer
	pisbol(p);	True if pointer is at beginning of line
	piseol(p);	True if pointer is at end of line
	pisbow(p);	True if pointer is at beginning of a word
	piseow(p);	True if pointer is at end of a word
</p>
<p>  More information about character at p:
	piscol(p);	Get column number of character at p.
</p>
<p>  Some other ways of moving a P through a B:
</p>
<p>	pnextl(p);	Go to beginning of next line
	pprevl(p);	Go to end of previous line
	pfwrd(p,int n);	Move forward n characters
	pbkwd(p,int n);	Move backward n characters
	p_goto_bof(p);
	p_goto_eof(p);
	p_goto_bol(p);
	p_goto_eol(p);
</p>
<p>	pset(p,q);	Move p to same position as q.
</p>
<p>	pline(p,n);	Goto to beginning of a specific line.
	pgoto(p,n);	Goto a specific byte position.
</p>
<p>	pfind(P,unsigned char *s,int len);
			Fast Boyer-Moore search forward.
</p>
<p>	prfind(P,unsigned char *s,int len);
			Fast Boyer-Moore search backward.
</p>
<p>		These are very fast- they look at low level
	data structure and don't go through pgetc().  Boyer-Moore
	allows you to skip over many characters without reading
	them, so you can get something like O(n/len).
</p>
<p>  Some facts:
</p>
<p>    Local operations are fast: pgetc(), prgetc().
</p>
<p>    Copy is fast: pset().
</p>
<p>    pline() and pgoto() are slower, but look for the closest existing
    P to start from.
</p>
<p>    The column number is stored in P, but it is only updated if
    it is easy to do so.  If it's hard (like you crossed a line
    boundary backward) it's marked as invalid.  piscol() then has
    to recalculate it.
</p>
<p>  Modifying a buffer:
</p>
<p>    binsc(p,int c);		Insert character at p.
    bdel(P *from,P *to);	Delete character between two Ps.
</p>
<p>  Note that when you insert or delete, all of the Ps after the insertion/
  deletion point are adjusted so that they continue to point to the same
  characeter before the insert or delete.
</p>
<p>  Insert and Delete create undo records.
</p>
<p>  Insert and Delete set dirty flags on lines which are currently being
  displayed on the screen, so that when you return to the edit loop, these
  lines automatically get redrawn.
</p>
<p>Internal:
</p>
<p>  An edit buffer is made up of a doubly-linked list of fixed sized (4 KB)
gap buffers.  A gap buffer has two parts: a ~16 byte header, which is always
in memory, and the actual buffer, which can be paged out to a swap file (a
vfile- see vfile.h).  A gap buffer consists of three regions: text before
the gap, the gap and text after the gap (which always goes all the way to
the end of buffer). (hole and ehole in the header indicate the gap
position).  The size of the gap may be 0 (which is the case when a file is
first loaded).  Gap buffers are fast for small inserts and deletes when the
cursor is at the gap (for delete you just adjust a pointer, for insert you
copy the data into gap).  When you reposition the cursor, you have to move
the gap before any inserts or deletes occur.  If you had only one window and
a single large gap buffer for the file, you could always keep the gap at the
cursor- the right-arrow key copies one character across the gap.
</p>
<p>  Of course for edits which span gap buffers or which are larger than a gap
buffer, you get a big mess of gap buffer splitting and merging plus
doubly-linked list splicing.
</p>
<p>  Still, this buffer method is quite fast: you never have to do large memory
moves since the gap buffers are limited in size.  To help search for line
numbers, the number of newlines '\n's contained in each gap buffer is stored
in the header.  Reads are fast as long as you have a P at the place you
want to read from, which is almost always the case.
</p>
<p>  It should be possible to quickly load files by mapping them directly into
memory (using mmap()) and treating each 4KB page as a gap buffer with 0 size
gap.  When page is modified, use copy-on-write to move the page into the
swap file (change pointer in header).  This is not done now.  Instead the
file is copied when loaded.
</p>
<h3>Windowing System</h3>
<p>There is a tiny object-oriented windowing system built into JOE.  This is
the class hierarchy:
</p>
<p>SCRN
  A optimizing terminal screen driver (very similar to 'curses').
    has a pointer to a CAP, which has the terminal capabilities read
    from termcap or terminfo.
</p>
<p>    writes output to screen with calls to the macro ttputc(). (tty.c is the
    actual interface to the tty device).
</p>
<p>    cpos()    - set cursor position
    outatr()  - draw a character at a screen position with attributes
    eraeol()  - erase from some position to the end of the line
</p>
<p>SCREEN
  Contains list of windows on the screen (W *topwin).
</p>
<p>  Points to window with focus (W *curwin).
</p>
<p>  Contains pointer to a 'SCRN', the tty driver for the particular terminal
  type.
</p>
<p>W
  A window on a screen.
</p>
<p>  Has position and size of window.
</p>
<p>  Has:
    void *object- pointer to a structure which inherits window (W should
    really be a base class for these objects- since C doesn't have this
    concept, a pointer to the derived class is used instead- the derived
    class has a pointer to the base class: it's called 'parent').
</p>
<p>      Currently this is one of:
        BW *    a text buffer window (screen update code is here.)
        QW *    query window (single character yes/no questions)
        MENU *  file selection menu
</p>
<p>      BW * is inherited by (in the same way that a BW inherits a W):
        PW *    a single line prompt window (file name prompts)
        TW *    a text buffer window (main editing window).
</p>
<p>    WATOM *watom- Gives type of this window.  The WATOM structure has
    pointers to virtual member functions.
</p>
<p>    KBD *kbd- The keyboard handler for this window.  When window has
    focus, keyboard events are sent to this object.  When key sequences
    are recognized, macros bound to them are invoked.
</p>
<p>Some window are operators on others.  For example ^K E, load a file into a
window prompt operates on a text window.  If you hit tab, a file selection
menu which operates on the prompt window appears below this.  When a window
is the target of operator windows is killed, the operators are killed also.
</p>
<p>Currently all windows are currently the width of the screen (should be fixed
in the future).  The windows are in a big circular list (think of a big loop
of paper).  The screen is small window onto this list.  So unlike emacs, you
can have windows which exist, but which are not on the screen.
</p>
<p>^K N and ^K P move the cursor to next or previous window.  If the next
window is off the screen it is moved onto the screen, along with any
operator windows are target it.
</p>
<h3>MACROS</h3>
<p>- add something here.
</p>
<h3>Screen update</h3>
<p>- add something here.
</p>
<h3>Files</h3>
main.c		has main().
</p>
<p>b.c		Text buffer management
undo.c		Undo system.
kbd.c		Keymap datastructure (keysequence to macro bindings).
macro.c		Keyboard and joerc file macros
help.c		Implement the on-line help window
poshist.c	Cursor position history
rc.c		joerc file loader
tab.c		tab completion for file selection prompt
regex.c		regular expressions
</p>
<p>blocks.c	Library: fast memcpy() functions (necessary on really old versions of UNIX).
dir.c		Directory reading functions (for old UNIXs).
hash.c		Library: simple hash functions.
vs.c		Automatic variable length strings (like C++ string).
va.c		Automatic array of strings (like STL container)
vfile.c		Library: virtual memory functions (allows you to edit files larger than memory)
utils.c		Misc. utilities
queue.c		Library: doubly linked lists
path.c		Library: file name and path manipulation functions
selinux.c	secure linux functions
</p>
<p>i18n.c		Unicode character type information database
charmap.c	UNICODE to 8-bit conversion functions
utf8.c		UTF-8 to unicode coding functions
</p>
<p>termcap.c	load terminal capabilities from /etc/termcap file or terminfo database
scrn.c		terminal update functions (curses)
syntax.c	syntax highlighter
</p>
<p>cmd.c		Table of user edit functions
ublock.c	User edit functions: block moves
uedit.c		User edit functions: basic edit functions
uerror.c	User edit functions: parse compiler error messages and goto next error, previous error
ufile.c		User edit functions: load and save file
uformat.c	User edit functions: paragraph formatting, centering
uisrch.c	User edit functions: incremental search
umath.c		User edit functions: calculator
usearch.c	User edit functions: search &amp; replace
ushell.c	User edit functions: subshell
utag.c		User edit functions: tags file search
</p>
<p>menu.c		A class: menu windows
tw.c		A class: main text editing window
qw.c		A class: query windows
pw.c		A class: prompt windows
bw.c		A class: text buffer window (screen update code is here)
w.c		A class: base class for all windows
</p>
